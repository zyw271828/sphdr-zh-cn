<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>加盐密码散列的正确方法</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="《加盐密码散列的正确方法（Salted Password Hashing - Doing it Right）》简体中文版">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded affix "><a href="ch00.html">前言</a></li><li class="chapter-item expanded "><a href="ch01.html"><strong aria-hidden="true">1.</strong> 什么是密码散列？</a></li><li class="chapter-item expanded "><a href="ch02.html"><strong aria-hidden="true">2.</strong> 散列是如何被破解的</a></li><li class="chapter-item expanded "><a href="ch03.html"><strong aria-hidden="true">3.</strong> 加盐</a></li><li class="chapter-item expanded "><a href="ch04.html"><strong aria-hidden="true">4.</strong> 无效的散列方法</a></li><li class="chapter-item expanded "><a href="ch05.html"><strong aria-hidden="true">5.</strong> 如何正确散列</a></li><li class="chapter-item expanded "><a href="ch06.html"><strong aria-hidden="true">6.</strong> 常见问题</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">加盐密码散列的正确方法</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/zyw271828/sphdr-zh-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="加盐密码散列的正确方法salted-password-hashing---doing-it-right简体中文版"><a class="header" href="#加盐密码散列的正确方法salted-password-hashing---doing-it-right简体中文版">加盐密码散列的正确方法（Salted Password Hashing - Doing it Right）简体中文版</a></h1>
<p>原文作者：<a href="https://defuse.ca/">Defuse Security</a></p>
<p>原文地址：<a href="https://crackstation.net/hashing-security.htm">CrackStation</a></p>
<p>原文仓库地址：<a href="https://github.com/defuse/crackstation">GitHub</a></p>
<p>译文对应版本：<a href="https://github.com/defuse/crackstation/commit/61d0fe75933ece3df5f5f9fdc564f90c4e25ff78"><code>61d0fe7</code></a> 2021-09-27 21:14:40</p>
<h2 id="构建"><a class="header" href="#构建">构建</a></h2>
<ul>
<li>
<p>安装 mdbook</p>
<pre><code class="language-bash">cargo install mdbook
</code></pre>
</li>
<li>
<p>运行 mdbook serve</p>
<pre><code class="language-bash">mdbook serve
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>如果您是一名 Web 开发者，您很可能需要建立一个用户账户系统。对用户账户系统来说，最重要的部分就是如何保护用户的密码。用户账户数据库经常被入侵，因此，如果您的网站遭到破坏，您绝对需要采取措施来保护用户的密码。保护密码的最佳方法是使用<strong>加盐密码散列（Salted Password Hashing）</strong>。这篇文章将会解释原因，并展示加盐密码散列的正确方法。</p>
<p>关于如何正确进行密码散列有很多相互矛盾的想法以及误解，可能是由于网络上的错误信息太多。其实，密码散列属于非常简单的事情，但有很多人都弄错了。在这篇文章里，我希望不仅可以解释正确的方法，还能解释为什么应该这样做。</p>
<blockquote>
<p><strong>重要警告：</strong> 如果您正在考虑自己编写密码散列代码，<strong>请不要这样做！</strong> 这太容易搞砸了。不，您在大学上的密码学课程不能让您免于这个警告。这适用于所有人：<strong>不要自己编写密码学算法！</strong> 毕竟存储密码的问题已经被解决了。您可以使用 <a href="http://www.openwall.com/phpass/">phpass</a>，位于 <a href="https://github.com/defuse/password-hashing">defuse/password-hashing</a> 的 PHP、C#、Java 和 Ruby 实现，或者 <a href="https://download.libsodium.org/doc/password_hashing/index.html">libsodium</a>。</p>
</blockquote>
<p>如果您由于某种原因错过了上面的大红色警告提示，请立即阅读它。真的，本指南<strong>并不是</strong>要引导您完成自己编写存储系统的过程，而是要解释为什么密码应该以某种特定的方式存储。</p>
<p>您可以使用以下链接跳转到文章的不同部分：</p>
<ol>
<li><a href="./ch01.html">什么是密码散列？</a></li>
<li><a href="./ch02.html">散列是如何被破解的</a></li>
<li><a href="./ch03.html">加盐</a></li>
<li><a href="./ch04.html">无效的散列方法</a></li>
<li><a href="./ch05.html">如何正确散列</a></li>
<li><a href="./ch06.html">常见问题</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是密码散列"><a class="header" href="#什么是密码散列">什么是密码散列？</a></h1>
<pre><code class="language-text">hash(&quot;hello&quot;) = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
hash(&quot;hbllo&quot;) = 58756879c05c68dfac9866712fad6a93f8146f337a69afe7dd238f3364946366
hash(&quot;waltz&quot;) = c0e81794384491161f1777c232bc6bd9ec38f616560b120fda8e90f383853542
</code></pre>
<p>散列算法是单向函数。它们将任意长度的数据转换为固定长度「指纹」，且无法逆转。它们还具有一种特性，即使输入发生一点点变化，生成的散列值也完全不同（参见上面的示例）。这对于保护密码来说非常有用，因为我们希望以一种即使密码文件本身被泄露也能保护密码的形式来存储密码，但同时，我们需要能够验证用户的密码是否正确。</p>
<p>基于散列的账户系统中账户注册和认证的一般工作流程如下：</p>
<ol>
<li>用户创建账户。</li>
<li>他们的密码被散列并存储在数据库中。这一过程的任何时候都不会将纯文本（未加密）密码写入硬盘。</li>
<li>当用户尝试登录时，他们输入密码的散列值会与他们真实密码的散列值（从数据库中检索）进行对比。</li>
<li>如果散列匹配，则授予用户访问权限。否则，用户会被告知他们输入了无效的登录凭据。</li>
<li>每次有人尝试登录其账户时，都会重复第 3 步和第 4 步。</li>
</ol>
<p>在第 4 步中，永远都不要告诉用户他们是弄错了用户名还是密码。应该始终显示诸如「无效的用户名或密码」之类的通用消息。这样可以防止攻击者在不知道密码的情况下枚举有效的用户名。</p>
<p>应该注意的是，用于保护密码的散列函数与您可能在数据结构课程中看到过的散列函数不同。用于实现散列表等数据结构的散列函数为快速而设计，而不是为安全而设计。只能使用 <strong>加密散列函数（Cryptographic Hash Function）</strong> 来实现密码散列。SHA256、SHA512、RipeMD 和 WHIRLPOOL 等散列函数属于加密散列函数。</p>
<p>很容易认为，您所要做的就是把密码丢进加密散列函数，您的用户密码就安全了。这与事实相去甚远。有很多方法可以非常快速地从普通散列中恢复密码。但是，有几种易于实现的技术可以使这些「攻击」的效果大打折扣。为了激发对这种技术的需求，请考虑这个网站（译者注：指原文所在的 <a href="https://crackstation.net/">CrackStation</a>）。在首页，您可以提交需要破解的一组散列，并在不到一秒钟的时间内收到结果。很显然，简单地对密码进行散列并不能满足我们的安全需求。</p>
<p>下一节将讨论一些用于破解普通密码散列的常见攻击。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="散列是如何被破解的"><a class="header" href="#散列是如何被破解的">散列是如何被破解的</a></h1>
<ul>
<li>
<p>字典攻击和暴力破解（Dictionary and Brute Force Attack）</p>
<pre><code class="language-text">字典攻击（Dictionary Attack）

正在尝试 apple        ：失败
正在尝试 blueberry    ：失败
正在尝试 justinbeiber ：失败
...
正在尝试 letmein      ：失败
正在尝试 s3cr3t       ：成功！
</code></pre>
<pre><code class="language-text">暴力破解（Brute Force Attack）

正在尝试 aaaa ：失败
正在尝试 aaab ：失败
正在尝试 aaac ：失败
...
正在尝试 acdb ：失败
正在尝试 acdc ：成功！
</code></pre>
<p>破解散列的最简单方法是试图猜出密码，对每个猜测进行散列，并检查猜测的散列是否与需要破解的散列相同。如果散列相同，那么猜测的值就是密码。猜测密码的两种最常见的方式是<strong>字典攻击</strong>和<strong>暴力破解</strong>。</p>
<p>字典攻击使用一些文件，其中包含单词、短语、常用密码和其他可能用作密码的字符串。文件中的每个单词都经过散列处理，并将得到的散列与密码散列进行比较。如果匹配，则这个单词就是密码。这些字典文件是从大量文本中提取出的单词，甚至是使用真实的密码数据库来构建的。字典文件通常会被进一步处理，使其变得更有效，比如使用「leet speak」进行替换（「hello」替换为「h3110」）。</p>
<p>暴力破解会尝试各种可能的字符组合，直到给定长度为止。这种攻击在计算上非常昂贵，并且通常在给定处理器时间内破解散列的效率最低，但最终总能找到密码。因此密码应该足够长，使得搜索所有可能的字符串来找到密码会因为花费太长时间而变得不值得。</p>
<p>没有办法防止字典攻击或暴力破解。虽然可以让它们变得不那么有效，但没有办法完全阻止它们。如果您的密码散列系统是安全的，则对每个散列运行字典攻击或暴力破解是破解散列的唯一方法。</p>
</li>
<li>
<p>查找表（Lookup Table）</p>
<pre><code class="language-text">正在搜索：5f4dcc3b5aa765d61d8327deb882cf99：已发现：password5
正在搜索：6cbe615c106f422d23669b610b564800：不在数据库中
正在搜索：630bf032efe4507f2c57b280995925a9：已发现：letMEin12
正在搜索：386f43fab5d096a7a66d67c8f213e5ec：已发现：mcd0nalds
正在搜索：d5ec75d5fe70d428685510fae36492d9：已发现：p@ssw0rd!
</code></pre>
<p>查找表是一种非常有效的方法，可以快速地破解许多相同类型的散列。总体思路是在密码字典中<strong>预先计算</strong>密码的散列值，并将散列值及其对应的密码存储在查找表数据结构中。良好实现的查找表可以在包含数十亿个散列的情况下每秒处理数百个散列查找。</p>
<p>如果您想更好地了解查找表的速度，请尝试使用 CrackStation 的<a href="https://crackstation.net/">免费散列破解器</a>破解以下 sha256 散列。</p>
<pre><code class="language-text">c11083b4b0a7743af748c85d343dfee9fbb8b2576c05f3a7f0d632b0926aadfc
08eac03b80adc33dc7d8fbe44b7c7b05d3a2c511166bdb43fcb710b03ba919e7
e4ba5cbd251c98e6cd1c23f126a3b81d8d8328abc95387229850952b3ef9f904
5206b8b8a996cf5320cb12ca91c7b790fba9f030408efe83ebb83548dc3007bd
</code></pre>
</li>
<li>
<p>反向查找表（Reverse Lookup Table）</p>
<pre><code class="language-text">正在用户散列列表中搜索 hash(apple)...     ：匹配 [alice3, 0bob0, charles8]
正在用户散列列表中搜索 hash(blueberry)... ：匹配 [usr10101, timmy, john91]
正在用户散列列表中搜索 hash(letmein)...   ：匹配 [wilson10, dragonslayerX, joe1984]
正在用户散列列表中搜索 hash(s3cr3t)...    ：匹配 [bruce19, knuth1337, john87]
正在用户散列列表中搜索 hash(z@29hjja)...  ：没有用户使用此密码
</code></pre>
<p>这种攻击允许攻击者同时对许多散列应用字典攻击或暴力破解，无需预先计算查找表。</p>
<p>首先，攻击者创建一个查找表，并将泄漏的用户账户数据库中的每个密码散列映射到具有该散列的用户列表。然后攻击者对每个密码猜测进行散列处理，并使用查找表来获取其密码与攻击者猜测相同的用户列表。这种攻击特别有效，因为多个用户拥有相同的密码是很常见的。</p>
</li>
<li>
<p>彩虹表（Rainbow Table）</p>
<p>彩虹表是一种使用时间换取空间的技术。它与查找表类似，只是牺牲了散列破解速度来使查找表更小。由于彩虹表更小，因此可以将更多散列的解存储在相同的空间中，使其更有效。可以破解任何不超过 8 个字符的密码的 md5 散列的彩虹表是<a href="http://www.freerainbowtables.com/en/tables2/">存在的</a>。</p>
</li>
</ul>
<p>接下来，我们将研究一种称为加盐的技术，它使得无法用查找表和彩虹表来破解散列。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="加盐"><a class="header" href="#加盐">加盐</a></h1>
<pre><code class="language-text">hash(&quot;hello&quot;)                    = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
hash(&quot;hello&quot; + &quot;QxLUF1bgIAdeQX&quot;) = 9e209040c863f84a31e719795b2577523954739fe5ed3b58a75cff2127075ed1
hash(&quot;hello&quot; + &quot;bv5PehSMfV11Cd&quot;) = d1d3ec2e6f20fd420d50e2642992841d8338a314b8ea157c9e18477aaef226ab
hash(&quot;hello&quot; + &quot;YYLmfY6IehjZMQ&quot;) = a49670c3c18b9e079b9cfaf51634f563dc8ae3070db2c4a8544305df1b60f007
</code></pre>
<p>查找表和彩虹表之所以有效，是因为每个密码都是以完全相同的方式进行散列的。如果两个用户拥有相同的密码，则他们也将拥有相同的密码散列值。我们可以通过随机化每个散列值来防止这种攻击，这样，当相同的密码被散列两次时，散列值会是不一样的。</p>
<p>我们可以在运行散列前向密码之后或之前添加一个称为<strong>盐</strong>的随机字符串来随机化散列值。如上例所示，这使得相同的密码每次散列后都变成完全不同的字符串。为了检查密码是否正确，我们需要盐，因此它通常与散列值一起存储在用户账户数据库中，或者作为散列值字符串本身的一部分。</p>
<p>盐不需要保密。仅仅通过随机化散列值，查找表、反向查找表和彩虹表就会变得无效。攻击者不会预先知道盐是什么，因此他们无法预先计算查找表或彩虹表。如果每个用户的密码都使用不同的盐进行散列，那么反向查找表攻击也将不起作用。</p>
<p>在下一节中，我们将展示盐通常是如何被错误地实现的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="无效的散列方法"><a class="header" href="#无效的散列方法">无效的散列方法</a></h1>
<h2 id="the-wrong-way-short-salt--salt-reuse"><a class="header" href="#the-wrong-way-short-salt--salt-reuse">The WRONG Way: Short Salt &amp; Salt Reuse</a></h2>
<p>The most common salt implementation errors are reusing the same salt in multiple hashes, or using a salt that is too short.</p>
<h3 id="salt-reuse"><a class="header" href="#salt-reuse">Salt Reuse</a></h3>
<p>A common mistake is to use the same salt in each hash. Either the salt is hard-coded into the program, or is generated randomly once. This is ineffective because if two users have the same password, they'll still have the same hash. An attacker can still use a reverse lookup table attack to run a dictionary attack on every hash at the same time. They just have to apply the salt to each password guess before they hash it. If the salt is hard-coded into a popular product, lookup tables and rainbow tables can be built for that salt, to make it easier to crack hashes generated by the product.</p>
<p>A new random salt must be generated each time a user creates an account or changes their password.</p>
<h3 id="short-salt"><a class="header" href="#short-salt">Short Salt</a></h3>
<p>If the salt is too short, an attacker can build a lookup table for every possible salt. For example, if the salt is only three ASCII characters, there are only 95x95x95 = 857,375 possible salts. That may seem like a lot, but if each lookup table contains only 1MB of the most common passwords, collectively they will be only 837GB, which is not a lot considering 1000GB hard drives can be bought for under $100 today.</p>
<p>For the same reason, the username shouldn't be used as a salt. Usernames may be unique to a single service, but they are predictable and often reused for accounts on other services. An attacker can build lookup tables for common usernames and use them to crack username-salted hashes.</p>
<p>To make it impossible for an attacker to create a lookup table for every possible salt, the salt must be long. A good rule of thumb is to use a salt that is the same size as the output of the hash function. For example, the output of SHA256 is 256 bits (32 bytes), so the salt should be at least 32 random bytes.</p>
<h2 id="the-wrong-way-double-hashing--wacky-hash-functions"><a class="header" href="#the-wrong-way-double-hashing--wacky-hash-functions">The WRONG Way: Double Hashing &amp; Wacky Hash Functions</a></h2>
<p>This section covers another common password hashing misconception: wacky combinations of hash algorithms. It's easy to get carried away and try to combine different hash functions, hoping that the result will be more secure. In practice, though, there is very little benefit to doing it. All it does is create interoperability problems, and can sometimes even make the hashes less secure. Never try to invent your own crypto, always use a standard that has been designed by experts. Some will argue that using multiple hash functions makes the process of computing the hash slower, so cracking is slower, but there's a better way to make the cracking process slower as we'll see later.</p>
<p>Here are some examples of poor wacky hash functions I've seen suggested in forums on the internet.</p>
<ul>
<li>md5(sha1(password))</li>
<li>md5(md5(salt) + md5(password))</li>
<li>sha1(sha1(password))</li>
<li>sha1(str_rot13(password + salt))</li>
<li>md5(sha1(md5(md5(password) + sha1(password)) + md5(password)))</li>
</ul>
<p>Do not use any of these.</p>
<p>Note: This section has proven to be controversial. I've received a number of emails arguing that wacky hash functions are a good thing, because it's better if the attacker doesn't know which hash function is in use, it's less likely for an attacker to have pre-computed a rainbow table for the wacky hash function, and it takes longer to compute the hash function.</p>
<p>An attacker cannot attack a hash when he doesn't know the algorithm, but note <a href="https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle">Kerckhoffs's principle</a>, that the attacker will usually have access to the source code (especially if it's free or open source software), and that given a few password-hash pairs from the target system, it is not difficult to reverse engineer the algorithm. It does take longer to compute wacky hash functions, but only by a small constant factor. It's better to use an iterated algorithm that's designed to be extremely hard to parallelize (these are discussed below). And, properly salting the hash solves the rainbow table problem.</p>
<p>If you really want to use a standardized &quot;wacky&quot; hash function like HMAC, then it's OK. But if your reason for doing so is to make the hash computation slower, read the section below about key stretching first.</p>
<p>Compare these minor benefits to the risks of accidentally implementing a completely insecure hash function and the interoperability problems wacky hashes create. It's clearly best to use a standard and well-tested algorithm.</p>
<h2 id="hash-collisions"><a class="header" href="#hash-collisions">Hash Collisions</a></h2>
<p>Because hash functions map arbitrary amounts of data to fixed-length strings, there must be some inputs that hash into the same string. Cryptographic hash functions are designed to make these collisions incredibly difficult to find. From time to time, cryptographers find &quot;attacks&quot; on hash functions that make finding collisions easier. A recent example is the MD5 hash function, for which collisions have actually been found.</p>
<p>Collision attacks are a sign that it may be more likely for a string other than the user's password to have the same hash. However, finding collisions in even a weak hash function like MD5 requires a lot of dedicated computing power, so it is very unlikely that these collisions will happen &quot;by accident&quot; in practice. A password hashed using MD5 and salt is, for all practical purposes, just as secure as if it were hashed with SHA256 and salt. Nevertheless, it is a good idea to use a more secure hash function like SHA256, SHA512, RipeMD, or WHIRLPOOL if possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="如何正确散列"><a class="header" href="#如何正确散列">如何正确散列</a></h1>
<h2 id="the-right-way-how-to-hash-properly"><a class="header" href="#the-right-way-how-to-hash-properly">The RIGHT Way: How to Hash Properly</a></h2>
<p>This section describes exactly how passwords should be hashed. The first subsection covers the basics—everything that is absolutely necessary. The following subsections explain how the basics can be augmented to make the hashes even harder to crack.</p>
<h3 id="the-basics-hashing-with-salt"><a class="header" href="#the-basics-hashing-with-salt">The Basics: Hashing with Salt</a></h3>
<p><strong>Warning: Do not just read this section. You absolutely must implement the stuff in the next section: &quot;Making Password Cracking Harder: Slow Hash Functions&quot;.</strong></p>
<p>We've seen how malicious hackers can crack plain hashes very quickly using lookup tables and rainbow tables. We've learned that randomizing the hashing using salt is the solution to the problem. But how do we generate the salt, and how do we apply it to the password?</p>
<p>Salt should be generated using a <strong>Cryptographically Secure Pseudo-Random Number Generator</strong> (CSPRNG). CSPRNGs are very different than ordinary pseudo-random number generators, like the &quot;C&quot; language's rand() function. As the name suggests, CSPRNGs are designed to be cryptographically secure, meaning they provide a high level of randomness and are completely unpredictable. We don't want our salts to be predictable, so we must use a CSPRNG. The following table lists some CSPRNGs that exist for some popular programming platforms.</p>
<table><thead><tr><th>Platform</th><th>CSPRNG</th></tr></thead><tbody>
<tr><td>PHP</td><td><a href="http://php.net/manual/en/function.mcrypt-create-iv.php">mcrypt_create_iv</a>, <a href="http://php.net/manual/en/function.openssl-random-pseudo-bytes.php">openssl_random_pseudo_bytes</a></td></tr>
<tr><td>Java</td><td><a href="http://docs.oracle.com/javase/6/docs/api/java/security/SecureRandom.html">java.security.SecureRandom</a></td></tr>
<tr><td>Dot NET (C#, VB)</td><td><a href="http://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider.aspx">System.Security.Cryptography.RNGCryptoServiceProvider</a></td></tr>
<tr><td>Ruby</td><td><a href="http://rubydoc.info/stdlib/securerandom/1.9.3/SecureRandom">SecureRandom</a></td></tr>
<tr><td>Python</td><td><a href="https://docs.python.org/3/library/secrets.html">secrets</a></td></tr>
<tr><td>Perl</td><td><a href="http://search.cpan.org/%7Emkanat/Math-Random-Secure-0.06/lib/Math/Random/Secure.pm">Math::Random::Secure</a></td></tr>
<tr><td>C/C++ (Windows API)</td><td><a href="http://en.wikipedia.org/wiki/CryptGenRandom">CryptGenRandom</a></td></tr>
<tr><td>Any language on GNU/Linux or Unix</td><td>Read from <a href="http://en.wikipedia.org/wiki//dev/random">/dev/random</a> or /dev/urandom</td></tr>
</tbody></table>
<p>The salt needs to be unique per-user per-password. Every time a user creates an account or changes their password, the password should be hashed using a new random salt. Never reuse a salt. The salt also needs to be long, so that there are many possible salts. As a rule of thumb, make your salt is at least as long as the hash function's output. The salt should be stored in the user account table alongside the hash.</p>
<h4 id="to-store-a-password"><a class="header" href="#to-store-a-password"><strong>To Store a Password</strong></a></h4>
<ol>
<li>Generate a long random salt using a CSPRNG.</li>
<li>Prepend the salt to the password and hash it with a <strong>standard</strong> password hashing function like Argon2, bcrypt, scrypt, or PBKDF2.</li>
<li>Save both the salt and the hash in the user's database record.</li>
</ol>
<h4 id="to-validate-a-password"><a class="header" href="#to-validate-a-password"><strong>To Validate a Password</strong></a></h4>
<ol>
<li>Retrieve the user's salt and hash from the database.</li>
<li>Prepend the salt to the given password and hash it using the same hash function.</li>
<li>Compare the hash of the given password with the hash from the database. If they match, the password is correct. Otherwise, the password is incorrect.</li>
</ol>
<h4 id="in-a-web-application-always-hash-on-the-server"><a class="header" href="#in-a-web-application-always-hash-on-the-server"><strong>In a Web Application, always hash on the server</strong></a></h4>
<p>If you are writing a web application, you might wonder where to hash. Should the password be hashed in the user's browser with JavaScript, or should it be sent to the server &quot;in the clear&quot; and hashed there?</p>
<p>Even if you are hashing the user's passwords in JavaScript, you still have to hash the hashes on the server. Consider a website that hashes users' passwords in the user's browser without hashing the hashes on the server. To authenticate a user, this website will accept a hash from the browser and check if that hash exactly matches the one in the database. This seems more secure than just hashing on the server, since the users' passwords are never sent to the server, but it's not.</p>
<p>The problem is that the client-side hash logically <em>becomes</em> the user's password. All the user needs to do to authenticate is tell the server the hash of their password. If a bad guy got a user's hash they could use it to authenticate to the server, without knowing the user's password! So, if the bad guy somehow steals the database of hashes from this hypothetical website, they'll have immediate access to everyone's accounts without having to guess any passwords.</p>
<p>This isn't to say that you <em>shouldn't</em> hash in the browser, but if you do, you absolutely have to hash on the server too. Hashing in the browser is certainly a good idea, but consider the following points for your implementation:</p>
<ul>
<li>
<p>Client-side password hashing is <strong>not</strong> a substitute for HTTPS (SSL/TLS). If the connection between the browser and the server is insecure, a man-in-the-middle can modify the JavaScript code as it is downloaded to remove the hashing functionality and get the user's password.</p>
</li>
<li>
<p>Some web browsers don't support JavaScript, and some users disable JavaScript in their browser. So for maximum compatibility, your app should detect whether or not the browser supports JavaScript and emulate the client-side hash on the server if it doesn't.</p>
</li>
<li>
<p>You need to salt the client-side hashes too. The obvious solution is to make the client-side script ask the server for the user's salt. Don't do that, because it lets the bad guys check if a username is valid without knowing the password. Since you're hashing and salting (with a good salt) on the server too, it's OK to use the username (or email) concatenated with a site-specific string (e.g. domain name) as the client-side salt.</p>
</li>
</ul>
<h3 id="making-password-cracking-harder-slow-hash-functions"><a class="header" href="#making-password-cracking-harder-slow-hash-functions">Making Password Cracking Harder: Slow Hash Functions</a></h3>
<p>Salt ensures that attackers can't use specialized attacks like lookup tables and rainbow tables to crack large collections of hashes quickly, but it doesn't prevent them from running dictionary or brute-force attacks on each hash individually. High-end graphics cards (GPUs) and custom hardware can compute billions of hashes per second, so these attacks are still very effective. To make these attacks less effective, we can use a technique known as <strong>key stretching</strong>.</p>
<p>The idea is to make the hash function very slow, so that even with a fast GPU or custom hardware, dictionary and brute-force attacks are too slow to be worthwhile. The goal is to make the hash function slow enough to impede attacks, but still fast enough to not cause a noticeable delay for the user.</p>
<p>Key stretching is implemented using a special type of CPU-intensive hash function. Don't try to invent your own–simply iteratively hashing the hash of the password isn't enough as it can be parallelized in hardware and executed as fast as a normal hash. Use a standard algorithm like <a href="http://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a> or <a href="http://en.wikipedia.org/wiki/Bcrypt">bcrypt</a>. You can find a PHP implementation of <a href="https://defuse.ca/php-pbkdf2.htm">PBKDF2 here</a>.</p>
<p>These algorithms take a security factor or iteration count as an argument. This value determines how slow the hash function will be. For desktop software or smartphone apps, the best way to choose this parameter is to run a short benchmark on the device to find the value that makes the hash take about half a second. This way, your program can be as secure as possible without affecting the user experience.</p>
<p>If you use a key stretching hash in a web application, be aware that you will need extra computational resources to process large volumes of authentication requests, and that key stretching may make it easier to run a Denial of Service (DoS) attack on your website. I still recommend using key stretching, but with a lower iteration count. You should calculate the iteration count based on your computational resources and the expected maximum authentication request rate. The denial of service threat can be eliminated by making the user solve a CAPTCHA every time they log in. Always design your system so that the iteration count can be increased or decreased in the future.</p>
<p>If you are worried about the computational burden, but still want to use key stretching in a web application, consider running the key stretching algorithm in the user's browser with JavaScript. The <a href="http://crypto.stanford.edu/sjcl/">Stanford JavaScript Crypto Library</a> includes PBKDF2. The iteration count should be set low enough that the system is usable with slower clients like mobile devices, and the system should fall back to server-side computation if the user's browser doesn't support JavaScript. Client-side key stretching does not remove the need for server-side hashing. You must hash the hash generated by the client the same way you would hash a normal password.</p>
<h3 id="impossible-to-crack-hashes-keyed-hashes-and-password-hashing-hardware"><a class="header" href="#impossible-to-crack-hashes-keyed-hashes-and-password-hashing-hardware">Impossible-to-crack Hashes: Keyed Hashes and Password Hashing Hardware</a></h3>
<p>As long as an attacker can use a hash to check whether a password guess is right or wrong, they can run a dictionary or brute-force attack on the hash. The next step is to add a secret key to the hash so that only someone who knows the key can use the hash to validate a password. This can be accomplished two ways. Either the hash can be encrypted using a cipher like AES, or the secret key can be included in the hash using a keyed hash algorithm like <a href="http://en.wikipedia.org/wiki/HMAC">HMAC</a>.</p>
<p>This is not as easy as it sounds. The key has to be kept secret from an attacker even in the event of a breach. If an attacker gains full access to the system, they'll be able to steal the key no matter where it is stored. The key must be stored in an external system, such as a physically separate server dedicated to password validation, or a special hardware device attached to the server such as the <a href="https://www.yubico.com/YubiHSM">YubiHSM</a>.</p>
<p>I highly recommend this approach for any large scale (more than 100,000 users) service. I consider it necessary for any service hosting more than 1,000,000 user accounts.</p>
<p>If you can't afford multiple dedicated servers or special hardware devices, you can still get some of the benefits of keyed hashes on a standard web server. Most databases are breached using <a href="http://en.wikipedia.org/wiki/SQL_injection">SQL Injection Attacks</a>, which, in most cases, don't give attackers access to the local filesystem (disable local filesystem access in your SQL server if it has this feature). If you generate a random key and store it in a file that isn't accessible from the web, and include it into the salted hashes, then the hashes won't be vulnerable if your database is breached using a simple SQL injection attack. Don't hard-code a key into the source code, generate it randomly when the application is installed. This isn't as secure as using a separate system to do the password hashing, because if there are SQL injection vulnerabilities in a web application, there are probably other types, such as Local File Inclusion, that an attacker could use to read the secret key file. But, it's better than nothing.</p>
<p>Please note that keyed hashes do not remove the need for salt. Clever attackers will eventually find ways to compromise the keys, so it is important that hashes are still protected by salt and key stretching.</p>
<h2 id="other-security-measures"><a class="header" href="#other-security-measures">Other Security Measures</a></h2>
<p>Password hashing protects passwords in the event of a security breach. It does not make the application as a whole more secure. Much more must be done to prevent the password hashes (and other user data) from being stolen in the first place.</p>
<p>Even experienced developers must be educated in security in order to write secure applications. A great resource for learning about web application vulnerabilities is <a href="https://www.owasp.org/index.php/Main_Page">The Open Web Application Security Project (OWASP)</a>. A good introduction is the <a href="https://www.owasp.org/images/7/72/OWASP_Top_10-2017_%28en%29.pdf.pdf">OWASP Top Ten Vulnerability List</a>. Unless you understand all the vulnerabilities on the list, do not attempt to write a web application that deals with sensitive data. It is the employer's responsibility to ensure all developers are adequately trained in secure application development.</p>
<p>Having a third party &quot;penetration test&quot; your application is a good idea. Even the best programmers make mistakes, so it always makes sense to have a security expert review the code for potential vulnerabilities. Find a trustworthy organization (or hire staff) to review your code on a regular basis. The security review process should begin early in an application's life and continue throughout its development.</p>
<p>It is also important to monitor your website to detect a breach if one does occur. I recommend hiring at least one person whose full time job is detecting and responding to security breaches. If a breach goes undetected, the attacker can make your website infect visitors with malware, so it is extremely important that breaches are detected and responded to promptly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h1>
<h2 id="what-hash-algorithm-should-i-use"><a class="header" href="#what-hash-algorithm-should-i-use">What hash algorithm should I use?</a></h2>
<p><strong>DO</strong> use:</p>
<ul>
<li>Well-designed key stretching algorithms such as <a href="http://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>, <a href="http://en.wikipedia.org/wiki/Bcrypt">bcrypt</a>, and <a href="http://www.tarsnap.com/scrypt.html">scrypt</a>.</li>
<li>OpenWall's <a href="http://www.openwall.com/phpass/">Portable PHP password hashing framework</a></li>
<li><a href="https://github.com/defuse/password-hashing">My implementations of PBKDF2 in PHP, C#, Java, and Ruby</a>.</li>
<li>Secure versions of <a href="http://en.wikipedia.org/wiki/Crypt_(Unix)#Library_Function_crypt.283.29">crypt</a> ($2y$, $5$, $6$)</li>
</ul>
<p><strong>DO NOT</strong> use:</p>
<ul>
<li>Fast cryptographic hash functions such as MD5, SHA1, SHA256, SHA512, RipeMD, WHIRLPOOL, SHA3, etc.</li>
<li>Insecure versions of crypt ($1$, $2$, $2x$, $3$).</li>
<li>Any algorithm that you designed yourself. Only use technology that is in the public domain and has been well-tested by experienced cryptographers.</li>
</ul>
<p>Even though there are no cryptographic attacks on MD5 or SHA1 that make their hashes easier to crack, they are old and are widely considered (somewhat incorrectly) to be inadequate for password storage. So I don't recommend using them. An exception to this rule is PBKDF2, which is frequently implemented using SHA1 as the underlying hash function.</p>
<h2 id="how-should-i-allow-users-to-reset-their-password-when-they-forget-it"><a class="header" href="#how-should-i-allow-users-to-reset-their-password-when-they-forget-it">How should I allow users to reset their password when they forget it?</a></h2>
<p>It is my personal opinion that all password reset mechanisms in widespread use today are insecure. If you have high security requirements, such as an encryption service would, do not let the user reset their password.</p>
<p>Most websites use an email loop to authenticate users who have forgotten their password. To do this, generate a random single-use token that is strongly tied to the account. Include it in a password reset link sent to the user's email address. When the user clicks a password reset link containing a valid token, prompt them for a new password. Be sure that the token is strongly tied to the user account so that an attacker can't use a token sent to his own email address to reset a different user's password.</p>
<p>The token must be set to expire in 15 minutes or after it is used, whichever comes first. It is also a good idea to expire any existing password tokens when the user logs in (they remembered their password) or requests another reset token. If a token doesn't expire, it can be forever used to break into the user's account. Email (SMTP) is a plain-text protocol, and there may be malicious routers on the internet recording email traffic. And, a user's email account (including the reset link) may be compromised long after their password has been changed. Making the token expire as soon as possible reduces the user's exposure to these attacks.</p>
<p>Attackers will be able to modify the tokens, so don't store the user account information or timeout information in them. They should be an unpredictable random binary blob used only to identify a record in a database table.</p>
<p>Never send the user a new password over email. Remember to pick a new random salt when the user resets their password. Don't re-use the one that was used to hash their old password.</p>
<h2 id="what-should-i-do-if-my-user-account-database-gets-leakedhacked"><a class="header" href="#what-should-i-do-if-my-user-account-database-gets-leakedhacked">What should I do if my user account database gets leaked/hacked?</a></h2>
<p>Your first priority is to determine how the system was compromised and patch the vulnerability the attacker used to get in. If you do not have experience responding to breaches, I highly recommend hiring a third-party security firm.</p>
<p>It may be tempting to cover up the breach and hope nobody notices. However, trying to cover up a breach makes you look worse, because you're putting your users at further risk by not informing them that their passwords and other personal information may be compromised. You must inform your users as soon as possible—even if you don't yet fully understand what happened. Put a notice on the front page of your website that links to a page with more detailed information, and send a notice to each user by email if possible.</p>
<p>Explain to your users exactly how their passwords were protected—hopefully hashed with salt—and that even though they were protected with a salted hash, a malicious hacker can still run dictionary and brute force attacks on the hashes. Malicious hackers will use any passwords they find to try to login to a user's account on a different website, hoping they used the same password on both websites. Inform your users of this risk and recommend that they change their password on any website or service where they used a similar password. Force them to change their password for your service the next time they log in. Most users will try to &quot;change&quot; their password to the original password to get around the forced change quickly. Use the current password hash to ensure that they cannot do this.</p>
<p>It is likely, even with salted slow hashes, that an attacker will be able to crack some of the weak passwords very quickly. To reduce the attacker's window of opportunity to use these passwords, you should require, in addition to the current password, an email loop for authentication until the user has changed their password. See the previous question, &quot;How should I allow users to reset their password when they forget it?&quot; for tips on implementing email loop authentication.</p>
<p>Also tell your users what kind of personal information was stored on the website. If your database includes credit card numbers, you should instruct your users to look over their recent and future bills closely and cancel their credit card.</p>
<h2 id="what-should-my-password-policy-be-should-i-enforce-strong-passwords"><a class="header" href="#what-should-my-password-policy-be-should-i-enforce-strong-passwords">What should my password policy be? Should I enforce strong passwords?</a></h2>
<p>If your service doesn't have strict security requirements, then don't limit your users. I recommend showing users information about the strength of their password as they type it, letting them decide how secure they want their password to be. If you have special security needs, enforce a minimum length of 12 characters and require at least two letters, two digits, and two symbols.</p>
<p>Do not force your users to change their password more often than once every six months, as doing so creates &quot;user fatigue&quot; and makes users less likely to choose good passwords. Instead, train users to change their password whenever they feel it has been compromised, and to never tell their password to anyone. If it is a business setting, encourage employees to use paid time to memorize and practice their password.</p>
<h2 id="if-an-attacker-has-access-to-my-database-cant-they-just-replace-the-hash-of-my-password-with-their-own-hash-and-login"><a class="header" href="#if-an-attacker-has-access-to-my-database-cant-they-just-replace-the-hash-of-my-password-with-their-own-hash-and-login">If an attacker has access to my database, can't they just replace the hash of my password with their own hash and login?</a></h2>
<p>Yes, but if someone has access to your database, they probably already have access to everything on your server, so they wouldn't need to login to your account to get what they want. The purpose of password hashing (in the context of a website) is not to protect the website from being breached, but to protect the passwords if a breach does occur.</p>
<p>You can prevent hashes from being replaced during a SQL injection attack by connecting to the database with two users with different permissions. One for the 'create account' code and one for the 'login' code. The 'create account' code should be able to read and write to the user table, but the 'login' code should only be able to read.</p>
<h2 id="why-do-i-have-to-use-a-special-algorithm-like-hmac-why-cant-i-just-append-the-password-to-the-secret-key"><a class="header" href="#why-do-i-have-to-use-a-special-algorithm-like-hmac-why-cant-i-just-append-the-password-to-the-secret-key">Why do I have to use a special algorithm like HMAC? Why can't I just append the password to the secret key?</a></h2>
<p>Hash functions like MD5, SHA1, and SHA2 use the <a href="http://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction">Merkle–Damgård construction</a>, which makes them vulnerable to what are known as length extension attacks. This means that given a hash H(X), an attacker can find the value of H(pad(X) + Y), for any other string Y, without knowing X. pad(X) is the padding function used by the hash.</p>
<p>This means that given a hash H(key + message), an attacker can compute H(pad(key + message) + extension), without knowing the key. If the hash was being used as a message authentication code, using the key to prevent an attacker from being able to modify the message and replace it with a different valid hash, the system has failed, since the attacker now has a valid hash of message + extension.</p>
<p>It is not clear how an attacker could use this attack to crack a password hash quicker. However, because of the attack, it is considered bad practice to use a plain hash function for keyed hashing. A clever cryptographer may one day come up with a clever way to use these attacks to make cracking faster, so use HMAC.</p>
<h2 id="should-the-salt-come-before-or-after-the-password"><a class="header" href="#should-the-salt-come-before-or-after-the-password">Should the salt come before or after the password?</a></h2>
<p>It doesn't matter, but pick one and stick with it for interoperability's sake. Having the salt come before the password seems to be more common.</p>
<h2 id="why-does-the-hashing-code-on-this-page-compare-the-hashes-in-length-constant-time"><a class="header" href="#why-does-the-hashing-code-on-this-page-compare-the-hashes-in-length-constant-time">Why does the hashing code on this page compare the hashes in &quot;length-constant&quot; time?</a></h2>
<p>Comparing the hashes in &quot;length-constant&quot; time ensures that an attacker cannot extract the hash of a password in an on-line system using a timing attack, then crack it off-line.</p>
<p>The standard way to check if two sequences of bytes (strings) are the same is to compare the first byte, then the second, then the third, and so on. As soon as you find a byte that isn't the same for both strings, you know they are different and can return a negative response immediately. If you make it through both strings without finding any bytes that differ, you know the strings are the same and can return a positive result. This means that comparing two strings can take a different amount of time depending on how much of the strings match.</p>
<p>For example, a standard comparison of the strings &quot;xyzabc&quot; and &quot;abcxyz&quot; would immediately see that the first character is different and wouldn't bother to check the rest of the string. On the other hand, when the strings &quot;aaaaaaaaaaB&quot; and &quot;aaaaaaaaaaZ&quot; are compared, the comparison algorithm scans through the block of &quot;a&quot; before it determines the strings are unequal.</p>
<p>Suppose an attacker wants to break into an on-line system that rate limits authentication attempts to one attempt per second. Also suppose the attacker knows all of the parameters to the password hash (salt, hash type, etc), except for the hash and (obviously) the password. If the attacker can get a precise measurement of how long it takes the on-line system to compare the hash of the real password with the hash of a password the attacker provides, he can use the timing attack to extract part of the hash and crack it using an offline attack, bypassing the system's rate limiting.</p>
<p>First, the attacker finds 256 strings whose hashes begin with every possible byte. He sends each string to the on-line system, recording the amount of time it takes the system to respond. The string that takes the longest will be the one whose hash's first byte matches the real hash's first byte. The attacker now knows the first byte, and can continue the attack in a similar manner on the second byte, then the third, and so on. Once the attacker knows enough of the hash, he can use his own hardware to crack it, without being rate limited by the system.</p>
<p>It might seem like it would be impossible to run a timing attack over a network. However, it has been done, and has been <a href="https://crypto.stanford.edu/%7Edabo/papers/ssl-timing.pdf">shown to be practical</a>. That's why the code on this page compares strings in a way that takes the same amount of time no matter how much of the strings match.</p>
<h2 id="how-does-the-slowequals-code-work"><a class="header" href="#how-does-the-slowequals-code-work">How does the SlowEquals code work?</a></h2>
<p>The previous question explains why SlowEquals is necessary, this one explains how the code actually works.</p>
<pre><code class="language-java">private static boolean slowEquals(byte[] a, byte[] b)
{
    int diff = a.length ^ b.length;
    for(int i = 0; i &lt; a.length &amp;&amp; i &lt; b.length; i++)
        diff |= a[i] ^ b[i];
    return diff == 0;
}
</code></pre>
<p>The code uses the XOR &quot;^&quot; operator to compare integers for equality, instead of the &quot;==&quot; operator. The reason why is explained below. The result of XORing two integers will be zero if and only if they are exactly the same. This is because 0 XOR 0 = 0, 1 XOR 1 = 0, 0 XOR 1 = 1, 1 XOR 0 = 1. If we apply that to all the bits in both integers, the result will be zero only if all the bits matched.</p>
<p>So, in the first line, if a.length is equal to b.length, the diff variable will get a zero value, but if not, it will get some non-zero value. Next, we compare the bytes using XOR, and OR the result into diff. This will set diff to a non-zero value if the bytes differ. Because ORing never un-sets bits, the only way diff will be zero at the end of the loop is if it was zero before the loop began (a.length == b.length) and all of the bytes in the two arrays match (none of the XORs resulted in a non-zero value).</p>
<p>The reason we need to use XOR instead of the &quot;==&quot; operator to compare integers is that &quot;==&quot; is usually translated/compiled/interpreted as a branch. For example, the C code <code>&quot;diff &amp;= a == b&quot;</code> might compile to the following x86 assembly:</p>
<pre><code class="language-assembly">MOV EAX, [A]
CMP [B], EAX
JZ equal
JMP done
equal:
AND [VALID], 1
done:
AND [VALID], 0
</code></pre>
<p>The branching makes the code execute in a different amount of time depending on the equality of the integers and the CPU's internal branch prediction state.</p>
<p>The C code <code>&quot;diff |= a ^ b&quot;</code> should compile to something like the following, whose execution time does not depend on the equality of the integers:</p>
<pre><code class="language-assembly">MOV EAX, [A]
XOR EAX, [B]
OR [DIFF], EAX
</code></pre>
<h2 id="why-bother-hashing"><a class="header" href="#why-bother-hashing">Why bother hashing?</a></h2>
<p>Your users are entering their password into your website. They are trusting you with their security. If your database gets hacked, and your users' passwords are unprotected, then malicious hackers can use those passwords to compromise your users' accounts on other websites and services (most people use the same password everywhere). It's not just your security that's at risk, it's your users'. You are responsible for your users' security.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
