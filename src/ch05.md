# 如何正确散列

## 正确的方法：如何正确散列

本节准确地描述了密码应该如何被散列。第一部分涵盖了基础方法——所有技术都是绝对有必要被应用的。接下来的部分解释了在基础方法之上如何增强，使散列更难被破解。

### 基础方法：加盐散列

> **警告：不要只阅读本节。您绝对必须实现下一节中的内容：「使密码破解更难：慢速散列函数」。**

我们已经看到了恶意黑客如何使用查找表和彩虹表非常快速地破解普通散列。我们已经了解到使用盐来随机化散列是解决这个问题的方法。但是我们如何生成盐，又如何将盐应用于密码呢？

盐应该使用 **密码学安全伪随机数生成器（Cryptographically Secure Pseudo-Random Number Generator，CSPRNG）** 生成。CSPRNG 与 C 语言 `rand()` 函数那样的普通的伪随机数生成器完全不同。顾名思义，CSPRNG 专为密码学安全而设计，这意味着它们可以提供高度随机性且完全不可预测。我们不希望我们的盐是可预测的，因此我们必须使用 CSPRNG。下表列出了一些流行编程平台提供的 CSPRNG。

| 平台                              | CSPRNG                                                |
| --------------------------------- | ----------------------------------------------------- |
| PHP                               | [mcrypt_create_iv](http://php.net/manual/en/function.mcrypt-create-iv.php)，[openssl_random_pseudo_bytes](http://php.net/manual/en/function.openssl-random-pseudo-bytes.php) |
| Java                              | [java.security.SecureRandom](http://docs.oracle.com/javase/6/docs/api/java/security/SecureRandom.html) |
| Dot NET（C#，VB）                 | [System.Security.Cryptography.RNGCryptoServiceProvider](http://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider.aspx) |
| Ruby                              | [SecureRandom](http://rubydoc.info/stdlib/securerandom/1.9.3/SecureRandom) |
| Python                            | [secrets](https://docs.python.org/3/library/secrets.html) |
| Perl                              | [Math::Random::Secure](http://search.cpan.org/~mkanat/Math-Random-Secure-0.06/lib/Math/Random/Secure.pm) |
| C/C++（Windows API）              | [CryptGenRandom](http://en.wikipedia.org/wiki/CryptGenRandom) |
| GNU/Linux 或 Unix 上的任何语言    | 从 [/dev/random](http://en.wikipedia.org/wiki//dev/random) 或 /dev/urandom 读取 |

每个用户每个密码的盐都应该是独一无二的。用户每次创建账户或更改密码时，都应该使用新的随机盐对密码进行散列。永远不要重复使用盐。盐需要足够长，这样可用的盐会足够多。根据经验，盐至少应该与散列函数的输出长度一样长。盐应该与散列一起存储在用户账户表中。

#### **存储密码时**

1. 使用 CSPRNG 生成长随机盐。
2. 在密码前附加盐并使用**标准**密码散列函数（如 Argon2、bcrypt、scrypt 或 PBKDF2）对其进行散列。
3. 将盐和散列保存在用户数据库记录中。

#### **验证密码时**

1. 从数据库中检索用户的盐和散列。
2. 将盐附加到给定的密码前并使用相同的散列函数对其进行散列。
3. 将给定密码的散列值与数据库中的散列值进行比较。如果匹配，则密码是正确的。否则，密码不正确。

#### **在 Web 应用程序中，始终在服务器上散列**

如果您正在编写 Web 应用程序，您可能想知道在哪里运行散列。密码应该在用户的浏览器中使用 JavaScript 散列，还是应该「以明文形式」发送到服务器并在服务器中散列？

即使您在 JavaScript 中散列了用户的密码，您仍然必须在服务器上对散列值再次进行散列。考虑一个网站，它在用户的浏览器中散列了用户的密码，却没有散列服务器上的散列值。为了对用户进行身份验证，该网站将接受来自浏览器的散列值并检查该散列值是否与数据库中的散列值完全匹配。这似乎比仅在服务器上散列更安全，因为用户的密码永远不会被发送到服务器，但事实并非如此。

问题在于，客户端的散列在逻辑上*成为了*用户的密码。用户进行身份验证所要做的就是告诉服务器他们密码的散列值。如果坏人获得了用户密码的散列值，他们就可以使用散列值用于服务器的身份验证，根本不需要知道用户的密码！因此，如果坏人以某种方式从这个假设的网站窃取了散列数据库，将可以立即访问每个人的账户，而无需猜测任何密码。

这并不是说您*不应该*在浏览器中散列，但如果您这样做了，也绝对必须在服务器上再次散列。在浏览器中进行散列当然是一个好主意，但在您的实现中，需要注意以下几点：

* 客户端密码散列并**不能**替代 HTTPS（SSL/TLS）。如果浏览器和服务器之间的连接不安全，中间人可以在浏览器下载 JavaScript 代码时修改它，删除散列功能并获取用户密码。

* 有些网络浏览器不支持 JavaScript，有些用户会在他们的浏览器中禁用 JavaScript。因此，为了获得最大的兼容性，您的应用程序应该检测浏览器是否支持 JavaScript，如果不支持，则在服务器上模拟客户端散列。

* 您还需要对客户端散列进行加盐。容易想到的解决方案是让客户端脚本向服务器请求用户的盐。不要这样做，因为这会让坏人在不知道密码的情况下检查用户名是否有效。由于您同样需要在服务器上进行散列和加盐（可以使用更好的盐），因此可以将用户名（或电子邮件）与特定于站点的字符串（例如域名）拼接在一起作为客户端的盐。

### 使密码破解更难：慢速散列函数

盐可以确保攻击者无法使用查找表和彩虹表等特定攻击来快速破解大量散列集合，但并不能阻止他们分别对每个散列运行字典攻击或暴力破解。高端显卡（GPU）和定制硬件每秒可以计算数十亿个散列值，因此这种攻击仍然非常有效。为了降低这种攻击的效率，我们可以使用一种称为 **密钥延伸（Key Stretching）** 的技术。

密钥延伸的想法是让散列函数变得非常慢，这样即使使用高速 GPU 或定制硬件，字典攻击和暴力破解也因太慢而变得不值得。目标是，使散列函数足够慢以阻止攻击，但仍然快到不会让用户感知到明显的延迟。

密钥延伸是使用一种特殊类型的 CPU 密集型散列函数实现的。不要试图发明您自己的版本——对密码的散列简单地进行迭代散列是不够的，因为这可以在硬件中并行化，和正常散列执行得一样快。应该使用 [PBKDF2](http://en.wikipedia.org/wiki/PBKDF2) 或 [bcrypt](http://en.wikipedia.org/wiki/Bcrypt) 这样的标准算法。您可以在[此处](https://defuse.ca/php-pbkdf2.htm)找到 PBKDF2 的 PHP 实现。

这些算法将安全系数或迭代次数作为参数。这个值决定了散列函数的速度有多慢。对于桌面软件或智能手机应用程序来说，选择此参数的最佳方法是在设备上运行一个简短的基准测试，找到使散列花费大约半秒时间的值。这样，您的程序可以在不影响用户体验的同时尽可能安全。

如果您在 Web 应用程序中使用密钥延伸散列，请注意您将需要额外的计算资源来处理大量身份验证请求，而且密钥延伸可能会让您的网站更容易遭到拒绝服务（Denial of Service，DoS）攻击。我仍然建议使用密钥延伸，但应该设置较小的迭代次数。您应该根据您的计算资源和预期的最大身份验证请求率来计算迭代次数。可以让用户在每次登录时输入验证码来消除拒绝服务威胁。总是应该将您的系统设计为可以方便地增加或减少迭代次数，以便将来进行调节。

如果您担心计算负担，但仍想在 Web 应用程序中使用密钥延伸，请考虑使用 JavaScript 在用户浏览器中运行密钥延伸算法。[斯坦福 JavaScript 加密库](http://crypto.stanford.edu/sjcl/)中包含了 PBKDF2。迭代次数应该设置得足够低，以便系统可以用于移动设备等速度较慢的客户端，如果用户的浏览器不支持 JavaScript，系统应该回退到服务器端进行计算。在客户端进行了密钥延伸并不意味着不需要在服务器端进行散列。您必须像散列正常密码一样散列客户端生成的散列值。

### Impossible-to-crack Hashes: Keyed Hashes and Password Hashing Hardware

As long as an attacker can use a hash to check whether a password guess is right or wrong, they can run a dictionary or brute-force attack on the hash. The next step is to add a secret key to the hash so that only someone who knows the key can use the hash to validate a password. This can be accomplished two ways. Either the hash can be encrypted using a cipher like AES, or the secret key can be included in the hash using a keyed hash algorithm like [HMAC](http://en.wikipedia.org/wiki/HMAC).

This is not as easy as it sounds. The key has to be kept secret from an attacker even in the event of a breach. If an attacker gains full access to the system, they'll be able to steal the key no matter where it is stored. The key must be stored in an external system, such as a physically separate server dedicated to password validation, or a special hardware device attached to the server such as the [YubiHSM](https://www.yubico.com/YubiHSM).

I highly recommend this approach for any large scale (more than 100,000 users) service. I consider it necessary for any service hosting more than 1,000,000 user accounts.

If you can't afford multiple dedicated servers or special hardware devices, you can still get some of the benefits of keyed hashes on a standard web server. Most databases are breached using [SQL Injection Attacks](http://en.wikipedia.org/wiki/SQL_injection), which, in most cases, don't give attackers access to the local filesystem (disable local filesystem access in your SQL server if it has this feature). If you generate a random key and store it in a file that isn't accessible from the web, and include it into the salted hashes, then the hashes won't be vulnerable if your database is breached using a simple SQL injection attack. Don't hard-code a key into the source code, generate it randomly when the application is installed. This isn't as secure as using a separate system to do the password hashing, because if there are SQL injection vulnerabilities in a web application, there are probably other types, such as Local File Inclusion, that an attacker could use to read the secret key file. But, it's better than nothing.

Please note that keyed hashes do not remove the need for salt. Clever attackers will eventually find ways to compromise the keys, so it is important that hashes are still protected by salt and key stretching.

## Other Security Measures

Password hashing protects passwords in the event of a security breach. It does not make the application as a whole more secure. Much more must be done to prevent the password hashes (and other user data) from being stolen in the first place.

Even experienced developers must be educated in security in order to write secure applications. A great resource for learning about web application vulnerabilities is [The Open Web Application Security Project (OWASP)](https://www.owasp.org/index.php/Main_Page). A good introduction is the [OWASP Top Ten Vulnerability List](https://www.owasp.org/images/7/72/OWASP_Top_10-2017_%28en%29.pdf.pdf). Unless you understand all the vulnerabilities on the list, do not attempt to write a web application that deals with sensitive data. It is the employer's responsibility to ensure all developers are adequately trained in secure application development.

Having a third party "penetration test" your application is a good idea. Even the best programmers make mistakes, so it always makes sense to have a security expert review the code for potential vulnerabilities. Find a trustworthy organization (or hire staff) to review your code on a regular basis. The security review process should begin early in an application's life and continue throughout its development.

It is also important to monitor your website to detect a breach if one does occur. I recommend hiring at least one person whose full time job is detecting and responding to security breaches. If a breach goes undetected, the attacker can make your website infect visitors with malware, so it is extremely important that breaches are detected and responded to promptly.
