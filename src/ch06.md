# 常见问题

## 我应该使用什么散列算法？

**可以**使用：

* 精心设计的密钥延伸算法，例如 [PBKDF2](http://en.wikipedia.org/wiki/PBKDF2)、[bcrypt](http://en.wikipedia.org/wiki/Bcrypt) 和 [scrypt](http://www.tarsnap.com/scrypt.html)。
* OpenWall 的[可移植 PHP 密码散列框架](http://www.openwall.com/phpass/)。
* [我在 PHP、C#、Java 和 Ruby 中对 PBKDF2 的实现](https://github.com/defuse/password-hashing)。
* [crypt](http://en.wikipedia.org/wiki/Crypt_(Unix)#Library_Function_crypt.283.29) 的安全版本（\$2y\$，\$5\$，\$6\$）。

**不要**使用：

* MD5、SHA1、SHA256、SHA512、RipeMD、WHIRLPOOL、SHA3 等快速加密散列函数。
* crypt 的不安全版本（\$1\$，\$2\$，\$2x\$，\$3\$）。
* 您自己设计的任何算法。应该只使用公共领域，且经过有经验的密码学家们充分测试的技术。

尽管还没有对 MD5 或 SHA1 的密码学攻击来让它们的散列更容易被破解，它们也已经过时并且被广泛认为（好像还不够广泛）强度不足以存储密码。所以我不建议使用它们。此规则的一个例外是 PBKDF2，它的实现经常把 SHA1 作为底层散列函数。

## 当用户忘记密码时，我应该如何让用户重置密码？

我个人认为，当今广泛使用的所有密码重置机制都是不安全的。如果您有很高的安全要求，例如提供加密服务，请不要让用户重置他们的密码。

大多数网站使用电子邮件循环来对忘记密码的用户进行身份验证。为此，需要生成一个与账户紧密相关的随机**一次性**令牌。将令牌包含在发送到用户电子邮件地址的密码重置链接中。当用户点击包含有效令牌的密码重置链接时，提示他们输入新密码。需要确保令牌与用户账户紧密相关，使攻击者无法用发送到自己电子邮件地址的令牌来重置其他用户的密码。

令牌必须设置为在 15 分钟后或使用后到期，以先到者为准。当用户登录（想起了密码）或请求另一个重置令牌时，让任何现有的密码令牌过期也是一个不错的主意。如果令牌永不过期，就可以永远被用于闯入用户的账户中。电子邮件（SMTP）是一种纯文本协议，互联网上可能存在记录电子邮件流量的恶意路由器。此外，用户的电子邮件账户（包括重置链接）可能会在用户密码更改很长时间之后被盗用。使令牌尽快到期可以减少用户遭受这些攻击的风险。

攻击者将会有能力修改令牌，因此不要在令牌中存储用户账户信息或超时信息。令牌应该是一个不可预测的随机二进制大型对象（BLOB），仅用于标识数据库表中的记录。

永远不要通过电子邮件向用户发送新密码。不要忘记在用户重置密码时选择一个新的随机盐。不要重复使用用于散列旧密码的盐。

## 如果我的用户账户数据库被泄露/入侵，我应该做什么？

您的首要任务是确定系统是如何被入侵的，并修补攻击者用来入侵的漏洞。如果您没有应对入侵行为的经验，我强烈建议您聘请第三方安全公司。

选择掩盖入侵行为并且希望没有人注意到入侵的发生可能十分诱人。但是，试图掩盖入侵行为会让您看起来更不负责任，因为您没有通知用户他们的密码和其他个人信息可能已经被泄露，从而使他们面临更大的风险。您必须尽快通知您的用户——即使您还没有完全理解发生了什么。请在您网站的首页放上一条通知，链接到包含更详细信息的页面，并尽可能通过电子邮件向每个用户发送通知。

向您的用户准确地解释他们的密码是如何被保护的——希望您使用了加盐散列——即使密码受到了加盐散列的保护，恶意黑客仍然可以对散列运行字典攻击和暴力破解。恶意黑客将使用他们找到的任何密码尝试登录不同网站上的用户账户，期望用户在两个网站上使用了相同的密码。将这种风险告知您的用户，并建议他们在使用了类似密码的任何网站或服务上更改密码。强制他们在下次登录您的服务时更改密码。大多数用户会尝试将他们的密码「更改」为与原来相同的密码来快速绕过强制更改。请使用当前密码的散列值来确保他们不能这样做。

即使使用了加盐的慢速散列，攻击者也很可能会很快破解出一些弱密码。为了减小攻击者使用这些密码的机会窗口，除了当前密码之外，您还应该要求用户使用电子邮件循环来进行身份验证，直到用户更改密码为止。请阅读上一个问题「当用户忘记密码时，我应该如何让用户重置密码？」中关于实现电子邮件循环身份验证的提示。

还应该将网站上存储了哪些类型的个人信息告知您的用户。如果您的数据库包含信用卡号，您应该指导您的用户仔细查看他们最近和未来的账单并注销他们的信用卡。

## 我的密码策略应该如何设置？我应该强制用户使用强密码吗？

如果您的服务没有严格的安全要求，就不要限制您的用户。我建议在用户输入密码时向他们展示有关密码强度的信息，让他们自己决定密码的安全性。如果您有特殊的安全需求，请强制要求密码的长度至少为 12 个字符，且至少有两个字母、两个数字和两个符号。

不要强迫您的用户以六个月一次更高的频率更改密码，因为这样做会造成「用户疲劳」，让用户不太可能选择好的密码。相反，应该培训用户在他们觉得密码已经被泄露时更改密码，并且永远不要将他们的密码告诉任何人。如果是商业环境，应该鼓励员工利用带薪时间来记住和练习他们的密码。

## 如果攻击者可以访问我的数据库，他们难道不能用自己的散列值替换掉我的密码散列值再登录吗？

的确可以，但是如果有人可以访问您的数据库，他们可能已经能够访问您服务器上的所有内容，因此他们无需登录您的账户就能获得他们想要的任何内容。在网站中使用的密码散列技术目的不在于保护网站不被攻破，而是在网站已经被攻破时保护密码。

您可以使用具有不同权限的两个用户连接到数据库来防止散列值在 SQL 注入攻击期间被替换。一个用户用于「创建账户」部分的语句，另一个用户用于「登录」部分的语句。「创建账户」部分的语句应该能读取和写入用户表，但「登录」部分的语句应该只能读取。

## 为什么我必须使用像 HMAC 这样的特殊算法？为什么我不能直接将密码附加到私钥后面？

Hash functions like MD5, SHA1, and SHA2 use the [Merkle–Damgård construction](http://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction), which makes them vulnerable to what are known as length extension attacks. This means that given a hash H(X), an attacker can find the value of H(pad(X) + Y), for any other string Y, without knowing X. pad(X) is the padding function used by the hash.

This means that given a hash H(key + message), an attacker can compute H(pad(key + message) + extension), without knowing the key. If the hash was being used as a message authentication code, using the key to prevent an attacker from being able to modify the message and replace it with a different valid hash, the system has failed, since the attacker now has a valid hash of message + extension.

It is not clear how an attacker could use this attack to crack a password hash quicker. However, because of the attack, it is considered bad practice to use a plain hash function for keyed hashing. A clever cryptographer may one day come up with a clever way to use these attacks to make cracking faster, so use HMAC.

## 盐应该在密码之前还是之后？

这不重要，但为了互操作性，请选择一种并坚持下去。在密码之前加盐似乎更常见。

## 为什么此页面上的散列代码会在「长度恒定」的时间内比较散列值？

Comparing the hashes in "length-constant" time ensures that an attacker cannot extract the hash of a password in an on-line system using a timing attack, then crack it off-line.

The standard way to check if two sequences of bytes (strings) are the same is to compare the first byte, then the second, then the third, and so on. As soon as you find a byte that isn't the same for both strings, you know they are different and can return a negative response immediately. If you make it through both strings without finding any bytes that differ, you know the strings are the same and can return a positive result. This means that comparing two strings can take a different amount of time depending on how much of the strings match.

For example, a standard comparison of the strings "xyzabc" and "abcxyz" would immediately see that the first character is different and wouldn't bother to check the rest of the string. On the other hand, when the strings "aaaaaaaaaaB" and "aaaaaaaaaaZ" are compared, the comparison algorithm scans through the block of "a" before it determines the strings are unequal.

Suppose an attacker wants to break into an on-line system that rate limits authentication attempts to one attempt per second. Also suppose the attacker knows all of the parameters to the password hash (salt, hash type, etc), except for the hash and (obviously) the password. If the attacker can get a precise measurement of how long it takes the on-line system to compare the hash of the real password with the hash of a password the attacker provides, he can use the timing attack to extract part of the hash and crack it using an offline attack, bypassing the system's rate limiting.

First, the attacker finds 256 strings whose hashes begin with every possible byte. He sends each string to the on-line system, recording the amount of time it takes the system to respond. The string that takes the longest will be the one whose hash's first byte matches the real hash's first byte. The attacker now knows the first byte, and can continue the attack in a similar manner on the second byte, then the third, and so on. Once the attacker knows enough of the hash, he can use his own hardware to crack it, without being rate limited by the system.

It might seem like it would be impossible to run a timing attack over a network. However, it has been done, and has been [shown to be practical](https://crypto.stanford.edu/~dabo/papers/ssl-timing.pdf). That's why the code on this page compares strings in a way that takes the same amount of time no matter how much of the strings match.

## SlowEquals 代码是如何工作的？

The previous question explains why SlowEquals is necessary, this one explains how the code actually works.

```java
private static boolean slowEquals(byte[] a, byte[] b)
{
    int diff = a.length ^ b.length;
    for(int i = 0; i < a.length && i < b.length; i++)
        diff |= a[i] ^ b[i];
    return diff == 0;
}
```

The code uses the XOR "^" operator to compare integers for equality, instead of the "==" operator. The reason why is explained below. The result of XORing two integers will be zero if and only if they are exactly the same. This is because 0 XOR 0 = 0, 1 XOR 1 = 0, 0 XOR 1 = 1, 1 XOR 0 = 1. If we apply that to all the bits in both integers, the result will be zero only if all the bits matched.

So, in the first line, if a.length is equal to b.length, the diff variable will get a zero value, but if not, it will get some non-zero value. Next, we compare the bytes using XOR, and OR the result into diff. This will set diff to a non-zero value if the bytes differ. Because ORing never un-sets bits, the only way diff will be zero at the end of the loop is if it was zero before the loop began (a.length == b.length) and all of the bytes in the two arrays match (none of the XORs resulted in a non-zero value).

The reason we need to use XOR instead of the "==" operator to compare integers is that "==" is usually translated/compiled/interpreted as a branch. For example, the C code `"diff &= a == b"` might compile to the following x86 assembly:

```assembly
MOV EAX, [A]
CMP [B], EAX
JZ equal
JMP done
equal:
AND [VALID], 1
done:
AND [VALID], 0
```

The branching makes the code execute in a different amount of time depending on the equality of the integers and the CPU's internal branch prediction state.

The C code `"diff |= a ^ b"` should compile to something like the following, whose execution time does not depend on the equality of the integers:

```assembly
MOV EAX, [A]
XOR EAX, [B]
OR [DIFF], EAX
```

## 为什么要用散列这么麻烦的东西？

您的用户正在您的网站中输入他们的密码。他们信任您并将他们的安全交给了您。如果您的数据库遭到入侵，而且用户的密码未受任何保护，则恶意黑客就可以使用这些密码来破坏您的用户在其他网站和服务上的账户（大多数人在所有地方都使用相同的密码）。面临风险的不仅是您的安全，还有您用户的安全。您应该对用户的安全负责。
